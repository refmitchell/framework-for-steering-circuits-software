"""
sim.py

This file contains utilities for running simple random walk simulations 
with the models defined in models.py.
"""

import numpy as np
import matplotlib.pyplot as plt
plt.rcParams["svg.fonttype"] = "none"


import util
import metrics
from models import MinimalCircuit, MP2024, UnintuitiveCircuit

from anti_models import AntiRuleOne, AntiRuleFour, AntiRuleFive, AntiRuleOneAndFive


def sim(model, goals, rate=50, duration=500):
    """
    Given a model and a set of goals, simulate the model attempting to follow each
    of these goals, assuming that the model starts facing the direction of its first
    goal. The 'goals' parameter is assumed to be a suitable walk generated by one
    of the processes in util.py.

    :param model: The model under test.
    :param goals: The set of goal directions to follow.
    :param rate: The number of model cycles (nominally) per second.
    :param duration: The duration of the simulation (nominally) in seconds.
    :return: The heading of the agent at each second of the simulation.
    """        
    print(model.id)
    goals = goals % (2*np.pi)

    agent_heading = goals[0]
    headings = [agent_heading]

    for t in range(duration - 1):
        for _ in range(rate):
            steering = model.update(agent_heading, goals[t])
            agent_heading -= steering

        headings.append(agent_heading)
    
    return headings


def multi_sim(anti_models=False, stepped=False):
    """
    Automatically run the simulation in sim() for multiple models and produce
    a plot showing the outputs for each, allowing comparison across models. This
    function will produce a plot output on disk.
    
    :param anti_models: Bool, if true the simulations will run with the anti-pattern
                        model examples
    """

    assert(not (stepped and anti_models))

    # Open the result from the optimisation procedure. 
    pos_result = np.load("DICE_result.pkl", allow_pickle=True)
    
    # Define model list for test
    models = []
    if anti_models:
        # Run simulations for antimodel figure
        models = [AntiRuleOne(), AntiRuleFour(), AntiRuleFive(), AntiRuleOneAndFive()]
    elif stepped:
        models = [MP2024(), UnintuitiveCircuit(pos_result.x)]
        Ns = [3]
        regular_models = [MinimalCircuit(n=n) for n in Ns] # Add a selection of uniform circuits
        antimodels = [AntiRuleOne(), AntiRuleOneAndFive()]
        models += regular_models
        models += antimodels
    else:
        # Run simulation for functional equivalence figure
        models = [MP2024(), UnintuitiveCircuit(pos_result.x)] # MP2024 and unintuitive model
        Ns = [3, 5, 8, 21]
        regular_models = [MinimalCircuit(n=n) for n in Ns] # Add a selection of uniform circuits
        models += regular_models
    

    duration = 1000
    variance = 0.3
    goals = util.generate_track(variance=variance, length=duration)
    
    if stepped:
        goals = util.generate_constant_turn_track(length=duration)

    # Fudge factor so that trace axes are roughly the same heights
    figsize = (8, len(models) + 1) if not anti_models else (8, (len(models) + 1)*1.05)

    f, axs = plt.subplots(len(models)+1, 1, figsize=figsize, sharex=True)

    for idx in range(1, len(models)+1):
        model = models[idx-1]
        headings = sim(model, goals, duration=duration)

        goals = np.array(goals) % (2*np.pi) 
        headings = np.array(headings) % (2*np.pi) 

        # Split goal and heading traces into line segments which avoid
        # crossing 0/2pi
        goals_split = util.split_trace(goals, range(duration))
        headings_split = util.split_trace(headings, range(duration))
        rmse_angle = metrics.rmse(goals, headings, angular=True)
        
        goals_unwrapped = np.unwrap(goals)    
        headings_unwrapped = np.unwrap(headings)

        ax = axs[idx]

        if stepped and model.id == 'Rule 1' or anti_models and model.id == 'Rule 1':
            ax.fill_between(range(len(headings)), np.radians(40), np.radians(80), color='tab:grey', alpha=0.2)
            ax.fill_between(range(len(headings)), np.radians(220), np.radians(260), color='tab:grey', alpha=0.2)
            
        elif stepped and model.id == '1 and 5' or anti_models and model.id == '1 and 5':
            ax.fill_between(range(len(headings)), np.radians(40), np.radians(80), color='tab:grey', alpha=0.2)
            ax.fill_between(range(len(headings)), np.radians(220), np.radians(260), color='tab:grey', alpha=0.2)

        # Plot heading and line segments
        for g in goals_split:    
            split_goals = [y for (_, y) in g]
            split_time = [x for (x, _) in g]
            ax.plot(split_time, split_goals, c='lightsteelblue')

        for h in headings_split:
            split_headings = [y for (_, y) in h]
            split_time = [x for (x, _) in h]
            ax.plot(split_time, split_headings, c='lightcoral')

        # Include RMSE 
        output_rmse = np.round(np.degrees(rmse_angle), decimals=2)
        
        ax.text(900, np.pi, 
                f"$\\epsilon = {output_rmse}\\degree$",
                size=8,
                bbox=dict(boxstyle='round', fc='w', ec='0.5', alpha=0.9))                
    

        ax.set_ylabel(model.id)

        ax.set_ylim([0, 2*np.pi])
        ax.set_yticks([0, 2*np.pi])
        ax.set_yticklabels(["$0\degree$", "$360\degree$"])
        ax.set_xlim([0, duration])

        if idx == len(models):
            ax.set_xlabel('Time (s)')
            

    ax = axs[0]
    for g in goals_split:    
        split_goals = [y for (_, y) in g]
        split_time = [x for (x, _) in g]
        ax.plot(split_time, split_goals, c='lightsteelblue')

    ax.set_ylabel("Goal")

    ax.set_ylim([0, 2*np.pi])
    ax.set_yticks([0, 2*np.pi])
    ax.set_yticklabels(["$0\degree$", "$360\degree$"])
    ax.set_xlim([0, duration])    
    
    
    plt.tight_layout()

    # Save as png
    filename = "unnamed.png"
    if anti_models:
        filename = "antimodel_tracks.png"
    elif stepped:
        filename = "stepped_model_tracks.png"
    else:
        filename = "model_tracks.png"
    
    plt.savefig(f"plots/{filename}", dpi=400, bbox_inches="tight")

if __name__ == "__main__":
    multi_sim()
    multi_sim(anti_models=True)
    multi_sim(stepped=True)
        
