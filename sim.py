"""
sim.py

This file contains utilities for running simple random walk simulations 
with the models defined in models.py.
"""

import numpy as np
import matplotlib.pyplot as plt
plt.rcParams["font.family"] = "serif"
plt.rcParams["font.serif"] = ["Times New Roman"]
plt.rcParams["mathtext.fontset"] = "cm"


import util
from models import MinimalCircuit, MP2024, UnintuitiveCircuit


def sim(model, goals, rate=50, duration=500):
    """
    Given a model and a set of goals, simulate the model attempting to follow each
    of these goals, assuming that the model starts facing the direction of its first
    goal. The 'goals' parameter is assumed to be a suitable walk generated by one
    of the processes in util.py.

    :param model: The model under test.
    :param goals: The set of goal directions to follow.
    :param rate: The number of model cycles (nominally) per second.
    :param duration: The duration of the simulation (nominally) in seconds.
    :return: The heading of the agent at each second of the simulation.
    """        
    print(model.id)
    goals = goals % (2*np.pi)

    agent_heading = goals[0]
    headings = [agent_heading]

    for t in range(duration - 1):
        for _ in range(rate):
            steering = model.update(agent_heading, goals[t])
            agent_heading -= steering

        headings.append(agent_heading)
    
    return headings


def multi_sim():
    """
    Automatically run the simulation in sim() for multiple models and produce
    a plot showing the outputs for each, allowing comparison across models. This
    function will produce a plot output on disk.
    """

    # Open the result from the optimisation procedure. 
    pos_result = np.load("DICE_result.pkl", allow_pickle=True)
    
    # Define model list for test
    models = [MP2024(), UnintuitiveCircuit(pos_result.x)] # MP2024 and unintuitive model
    Ns = [3, 5, 8, 21]
    regualar_models = [MinimalCircuit(n=n) for n in Ns] # Add a selection of uniform circuits
    models += regualar_models

    duration = 1000
    variance = 0.3
    goals = util.generate_track(show=False, variance=variance, length=duration)

    f, axs = plt.subplots(len(models), 1, figsize=(8,1*len(models)), sharex=True)

    for idx in range(len(models)):
        model = models[idx]
        headings = sim(model, goals, duration=duration)

        goals = np.unwrap(goals)    
        headings = np.unwrap(headings)

        n_shifts = 10
        shifts = np.arange(-n_shifts, (n_shifts+1), 1) * (2*np.pi)

        ax = axs[idx]
       
        for s in shifts:
            ax.plot(range(duration), goals + s, c='tab:blue', alpha=0.3)
            ax.plot(range(duration), headings + s, c='tab:red', alpha=0.3)

        ax.set_ylabel(model.id)

        ax.set_ylim([0, 2*np.pi])
        ax.set_yticks([0, 2*np.pi])
        ax.set_yticklabels(["0", "$2\pi$"])
        ax.set_xlim([0, duration])

        if idx == (len(models) - 1):
            ax.set_xlabel("Time (s)")
    
    plt.tight_layout()
    plt.savefig("plots/uniform_network_tracks_{}.png".format(variance), dpi=400, bbox_inches="tight")


if __name__ == "__main__":
    multi_sim()
        
