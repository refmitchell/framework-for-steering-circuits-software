"""
sim.py

This file contains utilities for running simple random walk simulations 
with the models defined in models.py.
"""

import numpy as np
import matplotlib.pyplot as plt
plt.rcParams["svg.fonttype"] = "none"


import util
import metrics
from models import MinimalCircuit, MP2024, UnintuitiveCircuit

from anti_models import AntiRuleOne, AntiRuleFour, AntiRuleFive


def sim(model, goals, rate=50, duration=500):
    """
    Given a model and a set of goals, simulate the model attempting to follow each
    of these goals, assuming that the model starts facing the direction of its first
    goal. The 'goals' parameter is assumed to be a suitable walk generated by one
    of the processes in util.py.

    :param model: The model under test.
    :param goals: The set of goal directions to follow.
    :param rate: The number of model cycles (nominally) per second.
    :param duration: The duration of the simulation (nominally) in seconds.
    :return: The heading of the agent at each second of the simulation.
    """        
    print(model.id)
    goals = goals % (2*np.pi)

    agent_heading = goals[0]
    headings = [agent_heading]

    for t in range(duration - 1):
        for _ in range(rate):
            steering = model.update(agent_heading, goals[t])
            agent_heading -= steering

        headings.append(agent_heading)
    
    return headings


def multi_sim(anti_models=False):
    """
    Automatically run the simulation in sim() for multiple models and produce
    a plot showing the outputs for each, allowing comparison across models. This
    function will produce a plot output on disk.
    
    :param anti_models: Bool, if true the simulations will run with the anti-pattern
                        model examples
    """

    # Open the result from the optimisation procedure. 
    pos_result = np.load("DICE_result.pkl", allow_pickle=True)
    
    # Define model list for test
    models = []
    if anti_models:
        models = [AntiRuleOne(), AntiRuleFour(), AntiRuleFive()]
    else:
        models = [MP2024(), UnintuitiveCircuit(pos_result.x)] # MP2024 and unintuitive model
        Ns = [3, 5, 8, 21]
        regular_models = [MinimalCircuit(n=n) for n in Ns] # Add a selection of uniform circuits
        models += regular_models
    

    duration = 1000
    variance = 0.3
    goals = util.generate_track(variance=variance, length=duration)


    # Fudge factor so that trace axes are roughly the same heights
    figsize = (8, len(models) + 1) if not anti_models else (8, (len(models) + 1)*1.05)

    f, axs = plt.subplots(len(models)+1, 1, figsize=figsize, sharex=True)

    for idx in range(1, len(models)+1):
        model = models[idx-1]
        headings = sim(model, goals, duration=duration)

        goals = np.array(goals) % (2*np.pi) 
        headings = np.array(headings) % (2*np.pi) 

        # Split goal and heading traces into line segments which avoid
        # crossing 0/2pi
        goals_split = util.split_trace(goals, range(duration))
        headings_split = util.split_trace(headings, range(duration))
        rmse_angle = metrics.rmse(goals, headings, angular=True)
        
        goals_unwrapped = np.unwrap(goals)    
        headings_unwrapped = np.unwrap(headings)
        goals_deriv = np.ediff1d(goals_unwrapped)
        headings_deriv = np.ediff1d(headings_unwrapped)

        rmse_deriv = metrics.rmse(goals_deriv, headings_deriv, angular=True)

        # n_shifts = 2
        # shifts = np.arange(-n_shifts, (n_shifts+1), 1) * (2*np.pi)

        ax = axs[idx]
       
        # for s in shifts:
        #     ax.plot(range(duration), goals + s, c='tab:blue', alpha=0.3)
        #     ax.plot(range(duration), headings + s, c='tab:red', alpha=0.3)

        # Plot heading and line segments
        for g in goals_split:    
            split_goals = [y for (_, y) in g]
            split_time = [x for (x, _) in g]
            ax.plot(split_time, split_goals, c='lightsteelblue')

        for h in headings_split:
            split_headings = [y for (_, y) in h]
            split_time = [x for (x, _) in h]
            ax.plot(split_time, split_headings, c='lightcoral')

        # # Plot derivatives
        # ax.plot(range(duration - 1), goals_deriv, c='lightsteelblue')
        # ax.plot(range(duration - 1), headings_deriv, c='lightcoral')

        # Include RMSE 
        output_rmse = np.round(np.degrees(rmse_angle), decimals=2)
        output_deriv_rmse = np.round(np.degrees(rmse_deriv), decimals=2)
        ax.text(900, np.pi, 
                f"$\\epsilon = {output_rmse}\\degree$\n$\\nu = {output_deriv_rmse}\\degree$",
                size=8,
                bbox=dict(boxstyle='round', fc='w', ec='0.5', alpha=0.9))

        ax.set_ylabel(model.id)

        ax.set_ylim([0, 2*np.pi])
        ax.set_yticks([0, 2*np.pi])
        ax.set_yticklabels(["0", "$2\pi$"])
        # ax.set_ylim([-np.pi,np.pi]) 
        # ax.set_yticks([-np.pi, 0, np.pi])
        # ax.set_yticklabels(["$-\pi$", 0, "$2\pi$"])
        ax.set_xlim([0, duration])

        if idx == len(models):
            ax.set_xlabel('Time (s)')
            

    ax = axs[0]
    for g in goals_split:    
        split_goals = [y for (_, y) in g]
        split_time = [x for (x, _) in g]
        ax.plot(split_time, split_goals, c='lightsteelblue')

    ax.set_ylabel("Goal")

    ax.set_ylim([0, 2*np.pi])
    ax.set_yticks([0, 2*np.pi])
    ax.set_yticklabels(["0", "$2\pi$"])
    ax.set_xlim([0, duration])    
    
    
    plt.tight_layout()

    # Save as png
    prefix = "anti" if anti_models else ""
    filename = f"{prefix}model_tracks.png"
    plt.savefig(f"plots/{filename}", dpi=400, bbox_inches="tight")

    # # Save as SVG
    # filename.replace(".png", ".svg")
    # plt.savefig(f"plots/{filename}", bbox_inches="tight")


if __name__ == "__main__":
    multi_sim()
    multi_sim(anti_models=True)
        
